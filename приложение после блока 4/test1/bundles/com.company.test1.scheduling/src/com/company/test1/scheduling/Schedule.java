package com.company.test1.scheduling;

import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import com.amalgamasimulation.core.scheduling.Gap;
import com.amalgamasimulation.core.scheduling.Sequence;
import com.amalgamasimulation.core.scheduling.TimeInterval;
import com.amalgamasimulation.utils.Pair;
import com.amalgamasimulation.utils.Utils;
import com.amalgamasimulation.utils.container.BiMap;
import com.amalgamasimulation.utils.time.Timeable;
import com.company.test1.datamodel.Changeover;
import com.company.test1.datamodel.Operation;
import com.company.test1.datamodel.PerformanceRecord;
import com.company.test1.datamodel.Product;
import com.company.test1.datamodel.Scenario;
import com.company.test1.datamodel.WorkCenter;
import com.company.test1.scheduling.alternatives.Alternative;
import com.company.test1.scheduling.selector.AlternativeSelector;
import com.company.test1.scheduling.slots.AbstractSlot;
import com.company.test1.scheduling.slots.ChangeoverSlot;
import com.company.test1.scheduling.slots.OperationSlot;
import com.company.test1.scheduling.slots.UnavailabilitySlot;
import com.company.test1.scheduling.slots.WorkCenterSlot;

/**
 * This class represents the current schedule, i.e., the sequence of
 * <b>operations</b> assigned to be done on a specific
 * <b>equipment</b> (work center) at some specific <b>time
 * window</b>.
 * <p>
 * The combination of operation, equipment, and time window is called a
 * <b>slot</b>. All slots within the same equipment unit form a
 * {@link Sequence} and have no intersection in time.
 * <p>
 * Initially, the {@link Schedule} class contains an empty schedule: no
 * operation is assigned.
 * <p>
 * The scheduling process is done step by step. During each scheduling step, one
 * or more slots are added to the schedule.
 * <p>
 * On each scheduling steps, there may be different sets of slots to add to the
 * schedule to keep it valid. Each such option (a set of one or several slots)
 * is called an {@link Alternative}. Alternatives are generated by the
 * {@link #createAlternatives()} method.
 * <p>
 * An {@link AlternativeSelector} object supplied to the {@link Schedule} class
 * constructor is used to decide which of the generated alternatives to apply on
 * each scheduling step.
 * <p>
 * An alternative may contain one slot or several slots. When an alternative is
 * applied, all slots it defines are atomically added to the current schedule.
 * <p>
 * The scheduling process is considered finished as soon as no slots have been
 * added during a scheduling step. The resulting schedule may still be incomplete
 * if not all required operations have been scheduled.
 * See the {@link #allOperationsAreScheduled()} method.
 *
 */
public class Schedule implements Timeable {
	
	public record WorkCenterAndSlotSequence(WorkCenter workCenter, Sequence<AbstractSlot> slots) {}
	
	private final Scenario scenario;
	private final AlternativeSelector selector;
	
	private int nextAlternativeId;
	private BiMap<WorkCenter, Sequence<AbstractSlot>> workCenterSequences = new BiMap<>();
	private Map<Operation, List<WorkCenter>> workCentersByOperations = new HashMap<>();
	private List<Pointer> pointers = new ArrayList<>();
	
	private Map<Product, Integer> completed = new LinkedHashMap<>();
	
	// (продукт, номер единицы продукции) - модельное время конца слота
	private Map<Pair<Product, Integer>, Double> lastAddedSlotEndTimes = new LinkedHashMap<>();
	
	private double totalCost;

	/**
	 * Constructs an instance with an empty schedule.
	 * 
	 * @param scenario           initial data for scheduling
	 * @param schedulingStrategy an object that encapsulates an algorithm for
	 *                           alternative generation and selection and the
	 *                           scheduling direction
	 */
	public Schedule(Scenario scenario, AlternativeSelector selector) {
		this.scenario = scenario;
		this.selector = selector;
		
		initializeSequences();
		for (PerformanceRecord performanceRecord : scenario.getPerformanceRecords()) {
			workCentersByOperations.computeIfAbsent(performanceRecord.getOperation(), k -> new ArrayList<>())
				.add(performanceRecord.getWorkCenter());
		}
		
		
		Map<Pair<Product, Integer>, OperationSlot> lastAddedOperationSlots = new LinkedHashMap<>();
		for (var assignment : scenario.getOperationAssignments()) {
			var operation = assignment.getOperation();
			var product = assignment.getProduct();
			int ppIndex = assignment.getProductionPlanItemIndex();
			int operationIndex = product.getOperations().indexOf(operation);
			OperationSlot slot = new OperationSlot(
					dateToTime(assignment.getBeginDate()),
					dateToTime(assignment.getEndDate()),
					assignment.getWorkCenter(),
					assignment.getCost(),
					operation,
					product,
					ppIndex,
					operationIndex);
			addSlot(slot);
			
			lastAddedOperationSlots.merge(new Pair<>(product, ppIndex), slot, (slot1, slot2) -> slot1.endTime() > slot2.endTime() ? slot1 : slot2);
		}
		
		for (var assignment : scenario.getUnavailabilityAssignments()) {
			var slot = new UnavailabilitySlot(
					dateToTime(assignment.getBeginDate()),
					dateToTime(assignment.getEndDate()),
					assignment.getWorkCenter());
			addSlot(slot);
		}

		createInitialPointers(lastAddedOperationSlots);
	}
	
	/**
	 * Добавить слот в расписание
	 */
	public void addSlot(AbstractSlot slot) {
		if (slot instanceof WorkCenterSlot workCenterSlot) {
			getWorkCenterSequence(workCenterSlot.getWorkCenter()).insert(workCenterSlot.beginTime(), workCenterSlot);
			addTotalCost(workCenterSlot.getCost());
			
			if (slot instanceof OperationSlot operationSlot) {
				Pair<Product, Integer> productItem = new Pair<>(operationSlot.getProduct(), operationSlot.getProductionPlanItemIndex());
				lastAddedSlotEndTimes.merge(productItem, operationSlot.endTime(), Double::max);
				
				Product product = operationSlot.getProduct();
				if (product.getOperations().size() - 1 == operationSlot.getOperationIndex()) {
					// доделали изделие
					addCompleted(product);
				}	
			}
		}
	}
	
	public double getLastAddedSlotEndTime(Product product, int planItemIndex) {
		return lastAddedSlotEndTimes.getOrDefault(new Pair<>(product, planItemIndex), 0.0);
	}
	
	public void addCompleted(Product product) {
		completed.merge(product, 1, Integer::sum);
	}
	
	public Map<Product, Integer> getCompleted() {
		return Collections.unmodifiableMap(completed);
	}
	
	public Pair<LocalDateTime, LocalDateTime> getActualScheduleBeginAndEndDate() {
		var modelTimePair = getActualScheduleBeginAndEndTime();
		if (modelTimePair != null) {
			return new Pair<>(timeToDate(modelTimePair.beginTime()), timeToDate(modelTimePair.endTime()));
		}
		return null;
	}
	
	// в терминах МОДЕЛЬНОГО ВРЕМЕНИ
	public TimeInterval getActualScheduleBeginAndEndTime() {
		double min = Double.POSITIVE_INFINITY;
		double max = Double.NEGATIVE_INFINITY;
		for (var sequence : workCenterSequences.values()) {
			var firstSlot = sequence.firstSlot(s -> true);
			if (firstSlot != null) {
				min = Math.min(min, firstSlot.beginTime());
			}
			var lastSlot = sequence.lastSlot(s -> true);
			if (lastSlot != null) {
				max = Math.max(max, lastSlot.endTime());
			}
		}
		if (Double.isFinite(min) && Double.isFinite(max)) {
			return new TimeInterval(min, max);
		}
		return null;
	}
	
	public double getUtilization(WorkCenter workCenter) {
		TimeInterval schedulingInterval = getActualScheduleBeginAndEndTime();
		if (schedulingInterval != null) {
			double operationTime = workCenterSequences.get(workCenter)
					.allSlots(slot -> slot instanceof OperationSlot operationSlot)
					.stream()
					.mapToDouble(slot -> slot.duration())
					.sum();
			return Utils.zidz(operationTime, schedulingInterval.duration());
		} else {
			// в расписании ещё нет ни одного слота операции
			return 0.0;
		}
	}
	
	public List<WorkCenterAndSlotSequence> getWorkCenterSequences() {
		return workCenterSequences.keys().stream()
						.map(e -> new WorkCenterAndSlotSequence(e, workCenterSequences.get(e)))
						.filter(p -> p.slots != null)
						.toList();
	}
		
	private void initializeSequences() {
		scenario.getWorkCenters().forEach(workCenter -> workCenterSequences.put(workCenter, new Sequence<>()));		
	}
	
	private void createInitialPointers(Map<Pair<Product, Integer>, OperationSlot> lastAddedOperationSlots) {
		Map<Product, Integer> productsAndQuantities = new HashMap<>();
		Map<Product, LocalDateTime> productsDeadlines = new HashMap<>();
		for (var rec : scenario.getProductionPlanRecords()) {
			productsAndQuantities.merge(rec.getProduct(), rec.getQuantity(), Integer::sum);
			productsDeadlines.merge(rec.getProduct(), rec.getPlannedDate(), (a, b) -> a.isAfter(b) ? b : a);
		}
		
		for (var entry : productsAndQuantities.entrySet()) {
			Product product = entry.getKey();
			for (int ppIndex = 0; ppIndex < entry.getValue(); ppIndex++) {
				// Создаём (или не создаём) Pointer для продукта product номер ppIndex
				
				OperationSlot lastAddedSlot = lastAddedOperationSlots.getOrDefault(new Pair<>(product, ppIndex), null);
				if (lastAddedSlot == null) {
					// pointer to the 1st operation of each production item
					pointers.add(new Pointer(this, product, entry.getValue(), ppIndex, 0, 0.0, Double.POSITIVE_INFINITY));
				} else if (lastAddedSlot.getOperationIndex() < product.getOperations().size() - 1) {
					int nextOperationIndex = lastAddedSlot.getOperationIndex() + 1;
					pointers.add(new Pointer(this, product, entry.getValue(), ppIndex, nextOperationIndex, 
							lastAddedSlot.endTime(), Double.POSITIVE_INFINITY));
				}
			}
		}
	}
	
	public double getTotalCost() {
		return totalCost;
	}
	
	public void addTotalCost(double delta) {
		this.totalCost += delta;
	}

	public Scenario getScenario() {
		return scenario;
	}
	
	@Override
	public ChronoUnit timeUnit() {
		return ChronoUnit.MINUTES;
	}
	
	@Override
	public LocalDateTime beginDate() {
		return scenario.getBeginDate();
	}
	
	public int nextAlternativeId() {
		return nextAlternativeId++;
	}
	
	/**
	 * Returns true if the schedule is <b>complete</b>.
	 */
	public boolean allOperationsAreScheduled() {
		//return pointers.isEmpty();
		var plan = getScenario().getProductionPlanRecords();
		var fact = getCompleted();
		
		for (var planRecord : plan) {
			var product = planRecord.getProduct();
			int planQuantity = planRecord.getQuantity();
			int factQuantity = fact.getOrDefault(product, 0);
			if (planQuantity > factQuantity) {
				return false;
			}
		}
		return true;
	}
	
	/**
	 * Makes one or more scheduling steps.
	 */
	public void schedule(int stepsCount) {
		int remainingStepsCount = stepsCount;
		Alternative nextAlternative;
		while (remainingStepsCount-- > 0 && (nextAlternative = getNextAlternative()) != null) {
			nextAlternative.apply();
		}
	}
	
	/**
	 * Returns the next alternative, if any. If no alternatives are available, returns {@code null}.
	 */
	private Alternative getNextAlternative() {
		List<Alternative> alternatives = generateAlternatives();
		if (alternatives.isEmpty()) {
			return null;
		}
		// вывести список альтернатив
		System.out.println("---");
		alternatives.forEach(System.out::println);

		// выбрать альтернативу, напечатать её и вернуть
		Alternative selected = selector.select(alternatives);
		System.out.println("SELECTED: " + selected);

		return selected;
	}
	
	/**
	 * Creates and returns a list of alternatives.
	 * Each alternative, when applied to the current schedule, will keep the schedule's correctness. 
	 */
	private List<Alternative> generateAlternatives() {
		List<Alternative> result = new ArrayList<>();
		for (Pointer pointer : pointers) {
			for (WorkCenter workCenter : getWorkCenters(pointer.getOperation())) {
				result.addAll(generateAlternativesForWorkCenter(pointer, workCenter));
			}
		}
		return result;
	}
	
	private List<Alternative> generateAlternativesForWorkCenter(Pointer pointer, WorkCenter workCenter) {
		var performanceRecord = getPerformanceRecord(workCenter, pointer.getOperation());
		if (performanceRecord == null) {
			return List.of();
		}
		
		final double duration = performanceRecord.getDurationMinutes();
		double minBeginTimeForOperation = pointer.getMinBeginTimeForOperation();
		if (Double.isInfinite(minBeginTimeForOperation)) {
			return List.of();
		}
		
		double maxEndTimeForOperation = pointer.getMaxEndTimeForOperation();
		if (maxEndTimeForOperation <= 0) {
			return List.of();
		}
		
		List<Alternative> result = new ArrayList<>();
		Sequence<AbstractSlot> workCenterSequence = getWorkCenterSequence(workCenter);
		List<Gap<AbstractSlot>> gaps = workCenterSequence.allGapsBetween(minBeginTimeForOperation, maxEndTimeForOperation);
		// find unoccupied time gaps large enough to perform the operation on the work center
		for (int gapIndex = 0; gapIndex < gaps.size(); gapIndex++) {
			var gap = gaps.get(gapIndex);
			var lastSlotBeforeGap = workCenterSequence.lastSlotBefore(gap.beginTime(), s -> true);
			
			Changeover changeover = null;
			if (lastSlotBeforeGap instanceof OperationSlot prevOperationSlot) {
				Operation prevOperation = prevOperationSlot.getOperation();
				changeover = getChangeover(workCenter, prevOperation, pointer.getOperation());
			}
			
			double changeoverDuration = changeover == null ? 0.0: changeover.getDurationMinutes();
			if (gap.duration() >= duration + changeoverDuration) {
				ChangeoverSlot changeoverSlot = null;
				if (changeoverDuration > 0) {
					changeoverSlot = new ChangeoverSlot(gap.beginTime(), gap.beginTime() + changeover.getDurationMinutes(), workCenter, changeover.getCost());
				}
				
				double operationSlotBeginTime = gap.beginTime() + changeoverDuration;
				double operationSlotEndTime = operationSlotBeginTime + duration;
				OperationSlot operationSlot = new OperationSlot(	operationSlotBeginTime, 
											operationSlotEndTime, 
											workCenter,
											performanceRecord.getCost(),
											pointer.getOperation(), 
											pointer.getProduct(), 
											pointer.getProductionPlanItemIndex(), 
											pointer.getOperationIndex());
				
				result.add(new Alternative(this, changeoverSlot, operationSlot, pointer));
			}
		}
		
		return result;
	}
	
	private Changeover getChangeover(WorkCenter workCenter, Operation prevOperation, Operation nextOperation) {
		return scenario.getChangeovers()	
				.stream()
				.filter(co -> 		co.getWorkCenter() == workCenter 
								&& 	co.getPrevOperation() == prevOperation 
								&&  co.getNextOperation() == nextOperation)
				.findFirst()
				.orElse(null);
	}
	
	private PerformanceRecord getPerformanceRecord(WorkCenter workCenter, Operation operation) {
		return getScenario()
				.getPerformanceRecords()
				.stream()
				.filter(perfRec -> perfRec.getOperation() == operation && perfRec.getWorkCenter() == workCenter)
				.findFirst()
				.orElse(null);
	}
	
	public List<Pointer> getPointers() {
		return pointers;
	}
	
	/**
	 * Returns equipment (work centers) capable of performing the requested operation.
	 */
	public List<WorkCenter> getWorkCenters(Operation currentOperation) {
		return workCentersByOperations.get(currentOperation);
	}

	/**
	 * Returns the current sequence of slots for the particular equipment (work center) 
	 */
	public Sequence<AbstractSlot> getWorkCenterSequence(WorkCenter workCenter) {
		return workCenterSequences.get(workCenter);
	}

	public void removePointer(Pointer pointer) {
		pointers.remove(pointer);		
	}

	public void addPointer(Pointer newPointer) {
		pointers.add(newPointer);		
	}
}
