package com.company.test1.scheduling;

import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import com.amalgamasimulation.core.scheduling.Gap;
import com.amalgamasimulation.core.scheduling.Sequence;
import com.amalgamasimulation.utils.Pair;
import com.amalgamasimulation.utils.container.BiMap;
import com.amalgamasimulation.utils.time.Timeable;
import com.company.test1.datamodel.Operation;
import com.company.test1.datamodel.PerformanceRecord;
import com.company.test1.datamodel.Product;
import com.company.test1.datamodel.Scenario;
import com.company.test1.datamodel.WorkCenter;
import com.company.test1.scheduling.alternatives.Alternative;
import com.company.test1.scheduling.selector.AlternativeSelector;
import com.company.test1.scheduling.slots.AbstractSlot;
import com.company.test1.scheduling.slots.OperationSlot;

/**
 * This class represents the current schedule, i.e., the sequence of
 * <b>operations</b> assigned to be done on a specific
 * <b>equipment</b> (work center) at some specific <b>time
 * window</b>.
 * <p>
 * The combination of operation, equipment, and time window is called a
 * <b>slot</b>. All slots within the same equipment unit form a
 * {@link Sequence} and have no intersection in time.
 * <p>
 * Initially, the {@link Schedule} class contains an empty schedule: no
 * operation is assigned.
 * <p>
 * The scheduling process is done step by step. During each scheduling step, one
 * or more slots are added to the schedule.
 * <p>
 * On each scheduling steps, there may be different sets of slots to add to the
 * schedule to keep it valid. Each such option (a set of one or several slots)
 * is called an {@link Alternative}. Alternatives are generated by the
 * {@link #createAlternatives()} method.
 * <p>
 * An {@link AlternativeSelector} object supplied to the {@link Schedule} class
 * constructor is used to decide which of the generated alternatives to apply on
 * each scheduling step.
 * <p>
 * An alternative may contain one slot or several slots. When an alternative is
 * applied, all slots it defines are atomically added to the current schedule.
 * <p>
 * The scheduling process is considered finished as soon as no slots have been
 * added during a scheduling step. The resulting schedule may still be incomplete
 * if not all required operations have been scheduled.
 * See the {@link #allOperationsAreScheduled()} method.
 *
 */
public class Schedule implements Timeable {
	
	public record WorkCenterAndSlotSequence(WorkCenter workCenter, Sequence<AbstractSlot> slots) {}
	
	private final Scenario scenario;
	private final AlternativeSelector selector;
	
	private int nextAlternativeId;
	private BiMap<WorkCenter, Sequence<AbstractSlot>> workCenterSequences = new BiMap<>();
	private Map<Operation, List<WorkCenter>> workCentersByOperations = new HashMap<>();
	private List<Pointer> pointers = new ArrayList<>();
	
	private Map<Product, Integer> completed = new LinkedHashMap<>();
	
	private double totalCost;

	/**
	 * Constructs an instance with an empty schedule.
	 * 
	 * @param scenario           initial data for scheduling
	 * @param schedulingStrategy an object that encapsulates an algorithm for
	 *                           alternative generation and selection and the
	 *                           scheduling direction
	 */
	public Schedule(Scenario scenario, AlternativeSelector selector) {
		this.scenario = scenario;
		this.selector = selector;
		initializeSequences();
		for (PerformanceRecord performanceRecord : scenario.getPerformanceRecords()) {
			workCentersByOperations.computeIfAbsent(performanceRecord.getOperation(), k -> new ArrayList<>())
				.add(performanceRecord.getWorkCenter());
		}
		createInitialPointers();
	}
	
	public void addCompleted(Product product) {
		completed.merge(product, 1, Integer::sum);
	}
	
	public Map<Product, Integer> getCompleted() {
		return Collections.unmodifiableMap(completed);
	}
	
	public Pair<LocalDateTime, LocalDateTime> getActualScheduleBeginAndEndTime() {
		double min = Double.POSITIVE_INFINITY;
		double max = Double.NEGATIVE_INFINITY;
		for (var sequence : workCenterSequences.values()) {
			var firstSlot = sequence.firstSlot(s -> true);
			if (firstSlot != null) {
				min = Math.min(min, firstSlot.beginTime());
			}
			var lastSlot = sequence.lastSlot(s -> true);
			if (lastSlot != null) {
				max = Math.max(max, lastSlot.endTime());
			}
		}
		if (Double.isFinite(min) && Double.isFinite(max)) {
			return new Pair<>(timeToDate(min), timeToDate(max));
		}
		return null;
	}
	
	public List<WorkCenterAndSlotSequence> getWorkCenterSequences() {
		return workCenterSequences.keys().stream()
						.map(e -> new WorkCenterAndSlotSequence(e, workCenterSequences.get(e)))
						.filter(p -> p.slots != null)
						.toList();
	}
		
	private void initializeSequences() {
		scenario.getWorkCenters().forEach(workCenter -> workCenterSequences.put(workCenter, new Sequence<>()));		
	}
	
	private void createInitialPointers() {
		Map<Product, Integer> productsAndQuantities = new HashMap<>();
		Map<Product, LocalDateTime> productsDeadlines = new HashMap<>();
		for (var rec : scenario.getProductionPlanRecords()) {
			productsAndQuantities.merge(rec.getProduct(), rec.getQuantity(), Integer::sum);
			productsDeadlines.merge(rec.getProduct(), rec.getPlannedDate(), (a, b) -> a.isAfter(b) ? b : a);
		}
		for (var entry : productsAndQuantities.entrySet()) {
			Product product = entry.getKey();
			// pointer to the 1st operation of the 1st production item
			pointers.add(new Pointer(this, product, entry.getValue(), 0, Double.POSITIVE_INFINITY));
		}
	}
	
	public double getTotalCost() {
		return totalCost;
	}
	
	public void addTotalCost(double delta) {
		this.totalCost += delta;
	}

	public Scenario getScenario() {
		return scenario;
	}
	
	@Override
	public ChronoUnit timeUnit() {
		return ChronoUnit.MINUTES;
	}
	
	@Override
	public LocalDateTime beginDate() {
		return scenario.getBeginDate();
	}
	
	public int nextAlternativeId() {
		return nextAlternativeId++;
	}
	
	/**
	 * Returns true if the schedule is <b>complete</b>.
	 */
	public boolean allOperationsAreScheduled() {
		//return pointers.isEmpty();
		var plan = getScenario().getProductionPlanRecords();
		var fact = getCompleted();
		
		for (var planRecord : plan) {
			var product = planRecord.getProduct();
			int planQuantity = planRecord.getQuantity();
			int factQuantity = fact.getOrDefault(product, 0);
			if (planQuantity > factQuantity) {
				return false;
			}
		}
		return true;
	}
	
	/**
	 * Makes one or more scheduling steps.
	 */
	public void schedule(int stepsCount) {
		int remainingStepsCount = stepsCount;
		Alternative nextAlternative;
		while (remainingStepsCount-- > 0 && (nextAlternative = getNextAlternative()) != null) {
			nextAlternative.apply();
		}
	}
	
	/**
	 * Returns the next alternative, if any. If no alternatives are available, returns {@code null}.
	 */
	private Alternative getNextAlternative() {
		List<Alternative> alternatives = generateAlternatives();
		if (alternatives.isEmpty()) {
			return null;
		}
		// вывести список альтернатив
		System.out.println("---");
		alternatives.forEach(System.out::println);

		// выбрать альтернативу, напечатать её и вернуть
		Alternative selected = selector.select(alternatives);
		System.out.println("SELECTED: " + selected);

		return selected;
	}
	
	/**
	 * Creates and returns a list of alternatives.
	 * Each alternative, when applied to the current schedule, will keep the schedule's correctness. 
	 */
	private List<Alternative> generateAlternatives() {
		List<Alternative> result = new ArrayList<>();
		for (Pointer pointer : pointers) {
			for (WorkCenter workCenter : getWorkCenters(pointer.getOperation())) {
				result.addAll(generateAlternativesForWorkCenter(pointer, workCenter));
			}
		}
		return result;
	}
	
	private List<Alternative> generateAlternativesForWorkCenter(Pointer pointer, WorkCenter workCenter) {
		var performanceRecord = getPerformanceRecord(workCenter, pointer.getOperation());
		if (performanceRecord == null) {
			return List.of();
		}
		
		final double duration = performanceRecord.getDurationMinutes();
		double minBeginTimeForOperation = pointer.getMinBeginTimeForOperation();
		if (Double.isInfinite(minBeginTimeForOperation)) {
			return List.of();
		}
		
		double maxEndTimeForOperation = pointer.getMaxEndTimeForOperation();
		if (maxEndTimeForOperation <= 0) {
			return List.of();
		}
		
		List<Alternative> result = new ArrayList<>();
		Sequence<AbstractSlot> workCenterSequence = getWorkCenterSequence(workCenter);
		List<Gap<AbstractSlot>> gaps = workCenterSequence.allGapsBetween(minBeginTimeForOperation, maxEndTimeForOperation);
		// find unoccupied time gaps large enough to perform the operation on the work center
		for (int gapIndex = 0; gapIndex < gaps.size(); gapIndex++) {
			var gap = gaps.get(gapIndex);
			if (gap.duration() >= duration) {
				double slotBeginTime = gap.beginTime();
				double slotEndTime = slotBeginTime + duration;
				OperationSlot slot = new OperationSlot(	slotBeginTime, 
											slotEndTime, 
											workCenter,
											performanceRecord.getCost(),
											pointer.getOperation(), 
											pointer.getProduct(), 
											pointer.getProductionPlanItemIndex(), 
											pointer.getOperationIndex());
				result.add(new Alternative(this, slot, pointer));
			}
		}
		
		return result;
	}
	
	private PerformanceRecord getPerformanceRecord(WorkCenter workCenter, Operation operation) {
		return getScenario()
				.getPerformanceRecords()
				.stream()
				.filter(perfRec -> perfRec.getOperation() == operation && perfRec.getWorkCenter() == workCenter)
				.findFirst()
				.orElse(null);
	}
	
	public List<Pointer> getPointers() {
		return pointers;
	}
	
	/**
	 * Returns equipment (work centers) capable of performing the requested operation.
	 */
	public List<WorkCenter> getWorkCenters(Operation currentOperation) {
		return workCentersByOperations.get(currentOperation);
	}

	/**
	 * Returns the current sequence of slots for the particular equipment (work center) 
	 */
	public Sequence<AbstractSlot> getWorkCenterSequence(WorkCenter workCenter) {
		return workCenterSequences.get(workCenter);
	}

	public void removePointer(Pointer pointer) {
		pointers.remove(pointer);		
	}

	public void addPointer(Pointer newPointer) {
		pointers.add(newPointer);		
	}
}
